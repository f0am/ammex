### This file was generated by Nexus Schema
### Do not make changes to this file directly


input BooleanFilter {
  equals: Boolean
  not: Boolean
}

input CustomerCreateOneWithoutTaskInput {
  connect: CustomerWhereUniqueInput
  create: CustomerCreateWithoutTaskInput
}

input CustomerCreateWithoutTaskInput {
  address: String!
  createdAt: DateTime
  email: String!
  id: String
  name: String!
  phone: String!
  updatedAt: DateTime
}

input CustomerUpdateOneRequiredWithoutTaskInput {
  connect: CustomerWhereUniqueInput
  create: CustomerCreateWithoutTaskInput
  update: CustomerUpdateWithoutTaskDataInput
  upsert: CustomerUpsertWithoutTaskInput
}

input CustomerUpdateWithoutTaskDataInput {
  address: String
  createdAt: DateTime
  email: String
  id: String
  name: String
  phone: String
  updatedAt: DateTime
}

input CustomerUpsertWithoutTaskInput {
  create: CustomerCreateWithoutTaskInput!
  update: CustomerUpdateWithoutTaskDataInput!
}

input CustomerWhereInput {
  address: StringFilter
  AND: [CustomerWhereInput!]
  createdAt: DateTimeFilter
  email: StringFilter
  id: UUIDFilter
  name: StringFilter
  NOT: [CustomerWhereInput!]
  OR: [CustomerWhereInput!]
  phone: StringFilter
  task: TaskFilter
  updatedAt: DateTimeFilter
}

input CustomerWhereUniqueInput {
  email: String
  id: String
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the
`date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO
8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

"""
The `JSON` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar Json

type Mutation {
  upsertOneUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NullableStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type Query {
  users(where: UserWhereInput): [User!]!
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

input TaskCommentCreateManyWithoutTaskInput {
  connect: [TaskCommentWhereUniqueInput!]
  create: [TaskCommentCreateWithoutTaskInput!]
}

input TaskCommentCreateManyWithoutUserInput {
  connect: [TaskCommentWhereUniqueInput!]
  create: [TaskCommentCreateWithoutUserInput!]
}

input TaskCommentCreateWithoutTaskInput {
  content: String!
  createdAt: DateTime
  id: String
  updatedAt: DateTime
  user: UserCreateOneWithoutTaskCommentsInput!
}

input TaskCommentCreateWithoutUserInput {
  content: String!
  createdAt: DateTime
  id: String
  task: TaskCreateOneWithoutTaskCommentsInput!
  updatedAt: DateTime
}

input TaskCommentFilter {
  every: TaskCommentWhereInput
  none: TaskCommentWhereInput
  some: TaskCommentWhereInput
}

input TaskCommentScalarWhereInput {
  AND: [TaskCommentScalarWhereInput!]
  content: StringFilter
  createdAt: DateTimeFilter
  id: UUIDFilter
  NOT: [TaskCommentScalarWhereInput!]
  OR: [TaskCommentScalarWhereInput!]
  taskId: StringFilter
  updatedAt: DateTimeFilter
  userId: StringFilter
}

input TaskCommentUpdateManyDataInput {
  content: String
  createdAt: DateTime
  id: String
  updatedAt: DateTime
}

input TaskCommentUpdateManyWithoutTaskInput {
  connect: [TaskCommentWhereUniqueInput!]
  create: [TaskCommentCreateWithoutTaskInput!]
  delete: [TaskCommentWhereUniqueInput!]
  deleteMany: [TaskCommentScalarWhereInput!]
  disconnect: [TaskCommentWhereUniqueInput!]
  set: [TaskCommentWhereUniqueInput!]
  update: [TaskCommentUpdateWithWhereUniqueWithoutTaskInput!]
  updateMany: [TaskCommentUpdateManyWithWhereNestedInput!]
  upsert: [TaskCommentUpsertWithWhereUniqueWithoutTaskInput!]
}

input TaskCommentUpdateManyWithoutUserInput {
  connect: [TaskCommentWhereUniqueInput!]
  create: [TaskCommentCreateWithoutUserInput!]
  delete: [TaskCommentWhereUniqueInput!]
  deleteMany: [TaskCommentScalarWhereInput!]
  disconnect: [TaskCommentWhereUniqueInput!]
  set: [TaskCommentWhereUniqueInput!]
  update: [TaskCommentUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [TaskCommentUpdateManyWithWhereNestedInput!]
  upsert: [TaskCommentUpsertWithWhereUniqueWithoutUserInput!]
}

input TaskCommentUpdateManyWithWhereNestedInput {
  data: TaskCommentUpdateManyDataInput!
  where: TaskCommentScalarWhereInput!
}

input TaskCommentUpdateWithoutTaskDataInput {
  content: String
  createdAt: DateTime
  id: String
  updatedAt: DateTime
  user: UserUpdateOneRequiredWithoutTaskCommentsInput
}

input TaskCommentUpdateWithoutUserDataInput {
  content: String
  createdAt: DateTime
  id: String
  task: TaskUpdateOneRequiredWithoutTaskCommentsInput
  updatedAt: DateTime
}

input TaskCommentUpdateWithWhereUniqueWithoutTaskInput {
  data: TaskCommentUpdateWithoutTaskDataInput!
  where: TaskCommentWhereUniqueInput!
}

input TaskCommentUpdateWithWhereUniqueWithoutUserInput {
  data: TaskCommentUpdateWithoutUserDataInput!
  where: TaskCommentWhereUniqueInput!
}

input TaskCommentUpsertWithWhereUniqueWithoutTaskInput {
  create: TaskCommentCreateWithoutTaskInput!
  update: TaskCommentUpdateWithoutTaskDataInput!
  where: TaskCommentWhereUniqueInput!
}

input TaskCommentUpsertWithWhereUniqueWithoutUserInput {
  create: TaskCommentCreateWithoutUserInput!
  update: TaskCommentUpdateWithoutUserDataInput!
  where: TaskCommentWhereUniqueInput!
}

input TaskCommentWhereInput {
  AND: [TaskCommentWhereInput!]
  content: StringFilter
  createdAt: DateTimeFilter
  id: UUIDFilter
  NOT: [TaskCommentWhereInput!]
  OR: [TaskCommentWhereInput!]
  task: TaskWhereInput
  taskId: StringFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: StringFilter
}

input TaskCommentWhereUniqueInput {
  id: String
}

input TaskCreateManyWithoutUserInput {
  connect: [TaskWhereUniqueInput!]
  create: [TaskCreateWithoutUserInput!]
}

input TaskCreateOneWithoutTaskCommentsInput {
  connect: TaskWhereUniqueInput
  create: TaskCreateWithoutTaskCommentsInput
}

input TaskCreateWithoutTaskCommentsInput {
  createdAt: DateTime
  customer: CustomerCreateOneWithoutTaskInput!
  description: String
  dueDate: DateTime!
  id: String
  name: String
  recurring: Boolean!
  TaskEvent: TaskEventCreateManyWithoutTaskInput
  type: TaskTypeCreateOneWithoutTaskInput!
  updatedAt: DateTime
  user: UserCreateOneWithoutTasksInput
}

input TaskCreateWithoutUserInput {
  createdAt: DateTime
  customer: CustomerCreateOneWithoutTaskInput!
  description: String
  dueDate: DateTime!
  id: String
  name: String
  recurring: Boolean!
  taskComments: TaskCommentCreateManyWithoutTaskInput
  TaskEvent: TaskEventCreateManyWithoutTaskInput
  type: TaskTypeCreateOneWithoutTaskInput!
  updatedAt: DateTime
}

input TaskEventCreateManyWithoutTaskInput {
  connect: [TaskEventWhereUniqueInput!]
  create: [TaskEventCreateWithoutTaskInput!]
}

input TaskEventCreateWithoutTaskInput {
  createdAt: DateTime
  description: String
  id: String
  time: DateTime
  type: String
}

input TaskEventFilter {
  every: TaskEventWhereInput
  none: TaskEventWhereInput
  some: TaskEventWhereInput
}

input TaskEventScalarWhereInput {
  AND: [TaskEventScalarWhereInput!]
  createdAt: DateTimeFilter
  description: NullableStringFilter
  id: UUIDFilter
  NOT: [TaskEventScalarWhereInput!]
  OR: [TaskEventScalarWhereInput!]
  taskId: StringFilter
  time: DateTimeFilter
  type: NullableStringFilter
}

input TaskEventUpdateManyDataInput {
  createdAt: DateTime
  description: String
  id: String
  time: DateTime
  type: String
}

input TaskEventUpdateManyWithoutTaskInput {
  connect: [TaskEventWhereUniqueInput!]
  create: [TaskEventCreateWithoutTaskInput!]
  delete: [TaskEventWhereUniqueInput!]
  deleteMany: [TaskEventScalarWhereInput!]
  disconnect: [TaskEventWhereUniqueInput!]
  set: [TaskEventWhereUniqueInput!]
  update: [TaskEventUpdateWithWhereUniqueWithoutTaskInput!]
  updateMany: [TaskEventUpdateManyWithWhereNestedInput!]
  upsert: [TaskEventUpsertWithWhereUniqueWithoutTaskInput!]
}

input TaskEventUpdateManyWithWhereNestedInput {
  data: TaskEventUpdateManyDataInput!
  where: TaskEventScalarWhereInput!
}

input TaskEventUpdateWithoutTaskDataInput {
  createdAt: DateTime
  description: String
  id: String
  time: DateTime
  type: String
}

input TaskEventUpdateWithWhereUniqueWithoutTaskInput {
  data: TaskEventUpdateWithoutTaskDataInput!
  where: TaskEventWhereUniqueInput!
}

input TaskEventUpsertWithWhereUniqueWithoutTaskInput {
  create: TaskEventCreateWithoutTaskInput!
  update: TaskEventUpdateWithoutTaskDataInput!
  where: TaskEventWhereUniqueInput!
}

input TaskEventWhereInput {
  AND: [TaskEventWhereInput!]
  createdAt: DateTimeFilter
  description: NullableStringFilter
  id: UUIDFilter
  NOT: [TaskEventWhereInput!]
  OR: [TaskEventWhereInput!]
  task: TaskWhereInput
  taskId: StringFilter
  time: DateTimeFilter
  type: NullableStringFilter
}

input TaskEventWhereUniqueInput {
  id: String
}

input TaskFilter {
  every: TaskWhereInput
  none: TaskWhereInput
  some: TaskWhereInput
}

input TaskScalarWhereInput {
  AND: [TaskScalarWhereInput!]
  createdAt: DateTimeFilter
  customerId: StringFilter
  description: NullableStringFilter
  dueDate: DateTimeFilter
  id: UUIDFilter
  name: NullableStringFilter
  NOT: [TaskScalarWhereInput!]
  OR: [TaskScalarWhereInput!]
  recurring: BooleanFilter
  taskComments: TaskCommentFilter
  TaskEvent: TaskEventFilter
  taskType: StringFilter
  updatedAt: DateTimeFilter
  userId: NullableStringFilter
}

input TaskTypeCreateOneWithoutTaskInput {
  connect: TaskTypeWhereUniqueInput
  create: TaskTypeCreateWithoutTaskInput
}

input TaskTypeCreateWithoutTaskInput {
  createdAt: DateTime
  id: String
  name: String!
  updatedAt: DateTime
}

input TaskTypeUpdateOneRequiredWithoutTaskInput {
  connect: TaskTypeWhereUniqueInput
  create: TaskTypeCreateWithoutTaskInput
  update: TaskTypeUpdateWithoutTaskDataInput
  upsert: TaskTypeUpsertWithoutTaskInput
}

input TaskTypeUpdateWithoutTaskDataInput {
  createdAt: DateTime
  id: String
  name: String
  updatedAt: DateTime
}

input TaskTypeUpsertWithoutTaskInput {
  create: TaskTypeCreateWithoutTaskInput!
  update: TaskTypeUpdateWithoutTaskDataInput!
}

input TaskTypeWhereInput {
  AND: [TaskTypeWhereInput!]
  createdAt: DateTimeFilter
  id: UUIDFilter
  name: StringFilter
  NOT: [TaskTypeWhereInput!]
  OR: [TaskTypeWhereInput!]
  task: TaskFilter
  updatedAt: DateTimeFilter
}

input TaskTypeWhereUniqueInput {
  id: String
  name: String
}

input TaskUpdateManyDataInput {
  createdAt: DateTime
  description: String
  dueDate: DateTime
  id: String
  name: String
  recurring: Boolean
  updatedAt: DateTime
}

input TaskUpdateManyWithoutUserInput {
  connect: [TaskWhereUniqueInput!]
  create: [TaskCreateWithoutUserInput!]
  delete: [TaskWhereUniqueInput!]
  deleteMany: [TaskScalarWhereInput!]
  disconnect: [TaskWhereUniqueInput!]
  set: [TaskWhereUniqueInput!]
  update: [TaskUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [TaskUpdateManyWithWhereNestedInput!]
  upsert: [TaskUpsertWithWhereUniqueWithoutUserInput!]
}

input TaskUpdateManyWithWhereNestedInput {
  data: TaskUpdateManyDataInput!
  where: TaskScalarWhereInput!
}

input TaskUpdateOneRequiredWithoutTaskCommentsInput {
  connect: TaskWhereUniqueInput
  create: TaskCreateWithoutTaskCommentsInput
  update: TaskUpdateWithoutTaskCommentsDataInput
  upsert: TaskUpsertWithoutTaskCommentsInput
}

input TaskUpdateWithoutTaskCommentsDataInput {
  createdAt: DateTime
  customer: CustomerUpdateOneRequiredWithoutTaskInput
  description: String
  dueDate: DateTime
  id: String
  name: String
  recurring: Boolean
  TaskEvent: TaskEventUpdateManyWithoutTaskInput
  type: TaskTypeUpdateOneRequiredWithoutTaskInput
  updatedAt: DateTime
  user: UserUpdateOneWithoutTasksInput
}

input TaskUpdateWithoutUserDataInput {
  createdAt: DateTime
  customer: CustomerUpdateOneRequiredWithoutTaskInput
  description: String
  dueDate: DateTime
  id: String
  name: String
  recurring: Boolean
  taskComments: TaskCommentUpdateManyWithoutTaskInput
  TaskEvent: TaskEventUpdateManyWithoutTaskInput
  type: TaskTypeUpdateOneRequiredWithoutTaskInput
  updatedAt: DateTime
}

input TaskUpdateWithWhereUniqueWithoutUserInput {
  data: TaskUpdateWithoutUserDataInput!
  where: TaskWhereUniqueInput!
}

input TaskUpsertWithoutTaskCommentsInput {
  create: TaskCreateWithoutTaskCommentsInput!
  update: TaskUpdateWithoutTaskCommentsDataInput!
}

input TaskUpsertWithWhereUniqueWithoutUserInput {
  create: TaskCreateWithoutUserInput!
  update: TaskUpdateWithoutUserDataInput!
  where: TaskWhereUniqueInput!
}

input TaskWhereInput {
  AND: [TaskWhereInput!]
  createdAt: DateTimeFilter
  customer: CustomerWhereInput
  customerId: StringFilter
  description: NullableStringFilter
  dueDate: DateTimeFilter
  id: UUIDFilter
  name: NullableStringFilter
  NOT: [TaskWhereInput!]
  OR: [TaskWhereInput!]
  recurring: BooleanFilter
  taskComments: TaskCommentFilter
  TaskEvent: TaskEventFilter
  taskType: StringFilter
  type: TaskTypeWhereInput
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: NullableStringFilter
}

input TaskWhereUniqueInput {
  id: String
}

type User {
  createdAt: DateTime!
  email: String!
  firstName: String!
  id: String!
  lastName: String!
  password: String!
  role: UserRole!
  updatedAt: DateTime!
}

input UserCreateInput {
  createdAt: DateTime
  email: String!
  firstName: String!
  id: String
  lastName: String!
  password: String!
  role: UserRole
  taskComments: TaskCommentCreateManyWithoutUserInput
  tasks: TaskCreateManyWithoutUserInput
  updatedAt: DateTime
}

input UserCreateOneWithoutTaskCommentsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutTaskCommentsInput
}

input UserCreateOneWithoutTasksInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutTasksInput
}

input UserCreateWithoutTaskCommentsInput {
  createdAt: DateTime
  email: String!
  firstName: String!
  id: String
  lastName: String!
  password: String!
  role: UserRole
  tasks: TaskCreateManyWithoutUserInput
  updatedAt: DateTime
}

input UserCreateWithoutTasksInput {
  createdAt: DateTime
  email: String!
  firstName: String!
  id: String
  lastName: String!
  password: String!
  role: UserRole
  taskComments: TaskCommentCreateManyWithoutUserInput
  updatedAt: DateTime
}

enum UserRole {
  ADMIN
  EMPLOYEE
}

input UserUpdateInput {
  createdAt: DateTime
  email: String
  firstName: String
  id: String
  lastName: String
  password: String
  role: UserRole
  taskComments: TaskCommentUpdateManyWithoutUserInput
  tasks: TaskUpdateManyWithoutUserInput
  updatedAt: DateTime
}

input UserUpdateOneRequiredWithoutTaskCommentsInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutTaskCommentsInput
  update: UserUpdateWithoutTaskCommentsDataInput
  upsert: UserUpsertWithoutTaskCommentsInput
}

input UserUpdateOneWithoutTasksInput {
  connect: UserWhereUniqueInput
  create: UserCreateWithoutTasksInput
  delete: Boolean
  disconnect: Boolean
  update: UserUpdateWithoutTasksDataInput
  upsert: UserUpsertWithoutTasksInput
}

input UserUpdateWithoutTaskCommentsDataInput {
  createdAt: DateTime
  email: String
  firstName: String
  id: String
  lastName: String
  password: String
  role: UserRole
  tasks: TaskUpdateManyWithoutUserInput
  updatedAt: DateTime
}

input UserUpdateWithoutTasksDataInput {
  createdAt: DateTime
  email: String
  firstName: String
  id: String
  lastName: String
  password: String
  role: UserRole
  taskComments: TaskCommentUpdateManyWithoutUserInput
  updatedAt: DateTime
}

input UserUpsertWithoutTaskCommentsInput {
  create: UserCreateWithoutTaskCommentsInput!
  update: UserUpdateWithoutTaskCommentsDataInput!
}

input UserUpsertWithoutTasksInput {
  create: UserCreateWithoutTasksInput!
  update: UserUpdateWithoutTasksDataInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  createdAt: DateTimeFilter
  email: StringFilter
  firstName: StringFilter
  id: UUIDFilter
  lastName: StringFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  password: StringFilter
  role: UserRole
  taskComments: TaskCommentFilter
  tasks: TaskFilter
  updatedAt: DateTimeFilter
}

input UserWhereUniqueInput {
  email: String
  id: String
}

scalar UUID

input UUIDFilter {
  contains: UUID
  endsWith: UUID
  equals: UUID
  gt: UUID
  gte: UUID
  in: [UUID!]
  lt: UUID
  lte: UUID
  not: UUID
  notIn: [UUID!]
  startsWith: UUID
}
